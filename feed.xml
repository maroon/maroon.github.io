<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Maroon</title>
    <link href="maroon.github.io/feed.xml" rel="self" />
    <link href="maroon.github.io" />
    <id>maroon.github.io/feed.xml</id>
    <author>
        <name>Ryan Maroon</name>
        <email>ryan.maroon@protonmail.com</email>
    </author>
    <updated>2018-12-11T00:00:00Z</updated>
    <entry>
    <title>Deploying Static Content with Hakyll</title>
    <link href="maroon.github.io/posts/2018/12/11/deploying-static-content-with-hakyll/" />
    <id>maroon.github.io/posts/2018/12/11/deploying-static-content-with-hakyll/</id>
    <published>2018-12-11T00:00:00Z</published>
    <updated>2018-12-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>When it comes time to deploy a Hakyll project using a service such as GitHub Pages, there is a tutorial <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">just for that.</a></p>
<p>Of course I wouldn’t be writing this if it had worked for me. I suspected it might not work out when I saw the files being copied between branches. For most, this solution may work without an issue. For myself, it was a constant source of pain. During the design phase of my project I realized that there should never be a reason to have the static web content follow the same flow of my development branch. It felt odd to have two disparate designs inhabiting the same path. To facilitate this design I created the <code>master</code> as an orphaned branch.</p>
<p>Because of this design decision, the helper script wouldn’t play nicely with the differences between branches. I had to update the <code>master</code>’s <code>.gitignore</code> file and adjust the <code>rsync</code> command to remove the unwanted files that remained during any branch checkouts.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode zsh"><code class="sourceCode zsh"><a class="sourceLine" id="cb1-1" title="1">rsync -a --filter=<span class="st">&#39;P _site/&#39;</span>       <span class="kw">\</span></a>
<a class="sourceLine" id="cb1-2" title="2">         --filter=<span class="st">&#39;P _cache/&#39;</span>      <span class="kw">\</span></a>
<a class="sourceLine" id="cb1-3" title="3">         --filter=<span class="st">&#39;P .git/&#39;</span>        <span class="kw">\</span></a>
<a class="sourceLine" id="cb1-4" title="4">         --filter=<span class="st">&#39;P .gitignore&#39;</span>   <span class="kw">\</span></a>
<a class="sourceLine" id="cb1-5" title="5">         --delete-excluded         <span class="kw">\</span></a>
<a class="sourceLine" id="cb1-6" title="6">         _site/ <span class="kw">.</span></a></code></pre></div>
<p>This is an abridged version of the <code>rsync</code> necessary to achieve what I wanted. It is important to note that there are changes to the command that caused additional side effects which are not present within the tutorial link above.</p>
<p>When using the <code>rsync</code> command from the tutorial I noticed several of my development files would “leak” over to the <code>master</code> branch, which I did not want. One option was to change the <code>.gitignore</code> file within the <code>master</code> branch to exclude these development related files. The problem that I faced was that some structures, such as the <code>post</code> directory, were shared between the <code>master</code> and development branches and could potentially require complex exclusion patterns. Therefore, I chose a different option: I instead decided to modify the <code>rsync</code> command in the deployment script since such structures would be overridden during its execution.</p>
<p>Obviously this became increasingly painful to maintain as the site grew in complexity. In addition to the script’s frailty, I often had to combat data loss when I failed to append additional filter commands for new files or directories. The script did hold together while I deployed the first few updates to the site. Once I was satisfied with how the site worked, I turned my attention to creating a better deployment solution for myself.</p>
<p><code>git</code> has a command called <code>worktree</code> that is defined as allowing the management of multiple working trees attached to the same repository. This amounts to performing a <code>checkout</code> on a branch which is then placed into a different directory than that of the working directory. As an aside, this is <a href="https://git-scm.com/docs/git-worktree/2.20.0#_bugs">often</a> a fantastic command for avoiding the typical <code>stash</code>/<code>commit</code>/<code>rebase</code> necessary to get the working directory back to its previous state after an emergency branch change.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode zsh"><code class="sourceCode zsh"><a class="sourceLine" id="cb2-1" title="1">git worktree remove -f _master</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">git stash -u</a>
<a class="sourceLine" id="cb2-4" title="4">git checkout devel</a>
<a class="sourceLine" id="cb2-5" title="5">./scripts/rebuild_site.sh</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">git worktree add _master master</a>
<a class="sourceLine" id="cb2-8" title="8">git fetch --all</a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">(cd</span> _master <span class="kw">&amp;&amp;</span> git merge --ff-only<span class="kw">)</span></a>
<a class="sourceLine" id="cb2-10" title="10"></a>
<a class="sourceLine" id="cb2-11" title="11">rsync -a _site/ _master/</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="kw">(cd</span> _master <span class="kw">&amp;&amp;</span> git add --all <span class="kw">&amp;&amp;</span> git commit -m <span class="st">&quot;</span><span class="ot">$1</span><span class="st">&quot;</span><span class="kw">)</span></a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15">git worktree remove -f _master</a></code></pre></div>
<p>Here is the core of the deployment script I came up with. Depending on workflow requirements some modifications to fetching and fast-forwarding might be necessary. Keep in mind that I haven’t had a reason to test this on a non-orphaned Hakyll project, although I would imagine that it should work in a similar fashion to the tutorial linked herein.</p>
<p>First it ensures that no work tree exists within the <code>_master</code> directory; if there is, any unsaved changes within the directory are lost. The steps following that are pretty straightforward: stash all changes, checkout the development branch, and preform a rebuild of the static web content. After that the <code>worktree</code> command is leveraged: it creates a working tree of the <code>master</code> branch inside the <code>_master</code> directory. The latest remote changes are fetched and the local <code>master</code> repository is fast-forwarded. It then issues an <code>rsync</code> command that copies the static web content contained within the <code>_site</code> directory into the <code>_master</code> directory. All the changes within <code>_master</code> are then staged and committed. Finally, the working tree is removed, leaving the development branch in a clean state and any unsaved changes at the top of the stash.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode zsh"><code class="sourceCode zsh"><a class="sourceLine" id="cb3-1" title="1">→ ./scripts/deploy.sh <span class="st">&quot;Commit message goes here!&quot;</span></a></code></pre></div>
<p>This is an example of a call to the deployment script. Note the argument given to it is passed along as the <code>master</code>’s commit message. After the script has finished I review the changes made to the <code>master</code> branch. If all looks well, I then push those changes to the remote repository.</p>]]></summary>
</entry>
<entry>
    <title>Localizing Transformations in Swift</title>
    <link href="maroon.github.io/posts/2018/11/08/localizing-transformations-in-swift/" />
    <id>maroon.github.io/posts/2018/11/08/localizing-transformations-in-swift/</id>
    <published>2018-11-08T00:00:00Z</published>
    <updated>2018-11-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The other day I was dealing with <code>CATransform3D</code> and found prototyping animations with it to be rather cumbersome. It wasn’t that the animations were difficult, or even hard to understand, rather it was that I found myself with far more clutter than I could keep track of. Simply rotating two views around a center point became tedious as both required slightly different variations of one another and thus were polluting the namespace with overlapping variables. Variables that I’d have to reassign, mutate, or name as one-offs. Creating a function was a bit over-the-top as I was still playing with ideas; I didn’t want anything concrete, nor did I want to waste time working out a common abstraction.</p>
<p>It was then that I found myself longing for days where I could create a new scope in C and be done with it. I began wondering what exactly that would look like in Swift. How would I go about creating something like that? I knew that I couldn’t just write an extension for <code>Any</code> as it is a non-nominal type, nor could I just throw it onto <code>AnyObject</code> because that would exclude <code>struct</code> types.</p>
<p>What I wanted was simple: a scope operator. The problem is that I have no way of representing that within the confines of the language. So what was I <em>really</em> after?</p>
<ol type="1">
<li>I would like semi-local variables that overlap in name, but don’t conflict and can remain immutable.</li>
<li>I want to deal with a convenient variable name rather than something like <code>view.layer.transform</code>.</li>
<li>I would like not to worry about an intermediary variable to assign the mutated value to.</li>
<li>I want to be able to specify a scope without creating new function definitions everywhere.</li>
</ol>
<p>The first item can be a little confusing for those that haven’t run into C scopes before. I’m going to express it here in Objective-C.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><a class="sourceLine" id="cb1-1" title="1">{</a>
<a class="sourceLine" id="cb1-2" title="2">  CGPoint point = CGPointMake(<span class="dv">5</span>, <span class="dv">12</span>);</a>
<a class="sourceLine" id="cb1-3" title="3">  {</a>
<a class="sourceLine" id="cb1-4" title="4">    CGPoint point = CGPointMake(<span class="dv">44</span>, <span class="dv">-11</span>);</a>
<a class="sourceLine" id="cb1-5" title="5">    NSLog(<span class="st">@&quot;%@&quot;</span>, NSStringFromCGPoint(point));</a>
<a class="sourceLine" id="cb1-6" title="6">  }</a>
<a class="sourceLine" id="cb1-7" title="7">  NSLog(<span class="st">@&quot;%@&quot;</span>, NSStringFromCGPoint(point));</a>
<a class="sourceLine" id="cb1-8" title="8">}</a></code></pre></div>
<p>Outputs:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><a class="sourceLine" id="cb2-1" title="1">{<span class="dv">44</span>, <span class="dv">-11</span>}</a>
<a class="sourceLine" id="cb2-2" title="2">{<span class="dv">5</span>, <span class="dv">12</span>}</a></code></pre></div>
<p>For me, being able to rapidly scope out details like this is an immeasurably powerful tool.</p>
<p>I started toying with the shape of these ideas by writing a function that would take a value and transform it.</p>
<pre class="swift"><code>let f: (CATransform3D) -&gt; CATransform3D = { transform in
  // Mutate
  return transform
}</code></pre>
<p>That’s a fine start, but there is a problem: I still would have to mess with intermediary variables. I couldn’t just tell the closure that I wanted to mutate the variable <code>transform</code>. <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md">Rest in peace, my sweet prince.</a> I’d have to create a new variable that was mutable within the scope of the closure.</p>
<pre class="swift"><code>let f: (CATransform3D) -&gt; CATransform3D = { transform in
  var transform = transform
  // Mutate
  return transform
}</code></pre>
<p>That’s pretty ugly. This design does say something about where to go from here, though. That says to me that I want to reassign the mutated value back to the original input. OK, that’s an easy enough change.</p>
<pre class="swift"><code>let f: (inout CATransform3D) -&gt; Void = { transform in
  // Mutate
}</code></pre>
<p>That is a <em>lot</em> closer to what I actually want. This also knocks out the first 3 items on the list! That last one though–– that’s going to be tough. Maybe with just a little luck and a bit of finesse I can get rid of the function variable name and…</p>
<pre class="swift"><code>_ = { (transform: inout CATransform3D) -&gt; Void in
  // Mutate
}(&amp;currentFace.layer.transform)</code></pre>
<p><a href="https://giphy.com/gifs/x-men-michael-fassbender-gdHpm6yTnzYJO">Perfection.</a></p>
<p>No. Just kidding. That’s downright awful. Arguably worse than where it just was.</p>
<p>Looking closely at how it is being expressed does give a hint about what is needed. This is forcing an assignment. Without <code>_ =</code> it won’t compile. Rather than throwing out a function that mutates a value, it might be better expressed as an operator.</p>
<p>I’m not really a fan of creating new operators, as most of the time I feel it can rapidly pollute the namespace with awkward or unnecessary structures. Used sparingly and when appropriate, I find them to be remarkably expressive.</p>
<pre class="swift"><code>infix operator =&gt;
func =&gt; &lt;T&gt;(value: inout T, transform: (inout T) throws -&gt; Void) rethrows {
  try transform(&amp;value)
}</code></pre>
<p>This will take some left-hand <code>value</code> and apply <code>transform</code> to it. Since the left-hand <code>value</code> is <code>T</code>, both of the parameters that involve <code>T</code> will require <code>inout</code> to be applied in order to permit mutation.</p>
<pre class="swift"><code>view.layer.transform =&gt; { transform in
  transform = CATransform3DTranslate(transform, x, y, 0.0)
  transform = CATransform3DRotate(transform, rotation, 1, 0, 0)
  transform = CATransform3DTranslate(transform, x, y, 0.0)
}</code></pre>
<p>Now all of the items on my list are crossed off and I have a very straightforward transform applied to the structure that I ultimately wanted to mutate.</p>]]></summary>
</entry>
<entry>
    <title>Hakyll Routes</title>
    <link href="maroon.github.io/posts/2018/10/02/hakyll-routes/" />
    <id>maroon.github.io/posts/2018/10/02/hakyll-routes/</id>
    <published>2018-10-02T00:00:00Z</published>
    <updated>2018-10-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>During the move to Hakyll, I decided it would be best to reflect on the slugs used within the site. The idea would be to strip off any HTML matter from the slug, making the slug itself the star of the show. The end result would look something like <code>/posts/yyyy/mm/dd/post-name/</code> or <code>/page-name/</code>.</p>
<p>I would need a base route to begin this process; a way to transmogrify all pages so that they had an <code>index.html</code> ending. From there I could build up more complex routes that were specific to different domains. Hakyll made composing routes very simple by providing a function aptly named <code>composeRoutes</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">indexRoute ::</span> <span class="dt">Routes</span></a>
<a class="sourceLine" id="cb1-2" title="2">indexRoute <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" title="3">  customRoute ((<span class="fu">&lt;/&gt;</span> <span class="st">&quot;index&quot;</span>) <span class="fu">.</span> dropExtension <span class="fu">.</span> toFilePath) <span class="ot">`composeRoutes`</span></a>
<a class="sourceLine" id="cb1-4" title="4">  setExtension <span class="st">&quot;html&quot;</span></a></code></pre></div>
<p>This takes whatever the file path of the identifier is, drops its extension, and appends <code>/index.html</code> to it. This gave me exactly what I was looking for and is now the route through which all others will pass. I then moved on to the heart of the system: posts.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode zsh"><code class="sourceCode zsh"><a class="sourceLine" id="cb2-1" title="1">→ <span class="kw">ls</span> -1p posts/</a>
<a class="sourceLine" id="cb2-2" title="2">2016-10-31-swift-package-manager-and-generics.md</a>
<a class="sourceLine" id="cb2-3" title="3">2017-10-14-swift-reusable-codable-structures.md</a>
<a class="sourceLine" id="cb2-4" title="4">2018-08-31-hakyll-sass-dependency.md</a></code></pre></div>
<p>Posts within the site adhere to a very simple date-title format. <code>gsubRoute</code> can be used to match against this pattern. By feeding it the date pattern and a function that replaces the dashes with directory separators, the desired directory structure is produced.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">dateRoute ::</span> <span class="dt">Routes</span></a>
<a class="sourceLine" id="cb3-2" title="2">dateRoute <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" title="3">  gsubRoute <span class="st">&quot;/[0-9]{4}-[0-9]{2}-[0-9]{2}-&quot;</span> (replaceAll <span class="st">&quot;-&quot;</span> <span class="fu">$</span> <span class="fu">const</span> <span class="st">&quot;/&quot;</span>) <span class="ot">`composeRoutes`</span></a>
<a class="sourceLine" id="cb3-4" title="4">  indexRoute</a></code></pre></div>
<p>This runs a regex over an identifier, replacing the post file format with an isomorphic directory structure. Note the composition with <code>indexRoute</code> above, which yields the final post slug: <code>/yyyy/mm/dd/post-name/index.html</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" title="2">  route dateRoute</a></code></pre></div>
<p>The last step is to add or update a <code>Rules</code> structure with the given route, and that’s it!</p>]]></summary>
</entry>
<entry>
    <title>Hakyll Sass Dependency</title>
    <link href="maroon.github.io/posts/2018/08/31/hakyll-sass-dependency/" />
    <id>maroon.github.io/posts/2018/08/31/hakyll-sass-dependency/</id>
    <published>2018-08-31T00:00:00Z</published>
    <updated>2018-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>One of the very first adventures I had in Hakyll was coming up with a way to get the Sass compiler working with it. Some time ago I had published a <a href="https://github.com/maroon/novella">theme for Jekyll</a>, which I had decided I wanted to keep around for this blog. I simply created a <code>scss</code> directory which housed the theme’s files.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode zsh"><code class="sourceCode zsh"><a class="sourceLine" id="cb1-1" title="1">→ <span class="kw">ls</span> -1p scss/</a>
<a class="sourceLine" id="cb1-2" title="2">novella/</a>
<a class="sourceLine" id="cb1-3" title="3">novella.scss</a></code></pre></div>
<p>The solution didn’t require much knowledge of the inner workings of Hakyll. Rather, it was more about knowing how to manipulate the arguments for <code>sass</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">match <span class="st">&quot;scss/*.scss&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" title="2">  route <span class="fu">$</span> constRoute <span class="st">&quot;assets/main.css&quot;</span></a>
<a class="sourceLine" id="cb2-3" title="3">  compile compressScssCompiler</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="ot">compressScssCompiler ::</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">compressScssCompiler <span class="fu">=</span> withItemBody <span class="fu">$</span> unixFilter <span class="st">&quot;sass&quot;</span> arguments</a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" title="8">    arguments <span class="fu">=</span> [ <span class="st">&quot;-s&quot;</span></a>
<a class="sourceLine" id="cb2-9" title="9">                , <span class="st">&quot;--scss&quot;</span></a>
<a class="sourceLine" id="cb2-10" title="10">                , <span class="st">&quot;--style&quot;</span>, <span class="st">&quot;compressed&quot;</span></a>
<a class="sourceLine" id="cb2-11" title="11">                , <span class="st">&quot;--load-path&quot;</span>, <span class="st">&quot;scss&quot;</span></a>
<a class="sourceLine" id="cb2-12" title="12">                ]</a></code></pre></div>
<p>Here I tell it to match any SCSS files within the <code>scss</code> directory, in this case it is only the <code>novella.scss</code> file, and that in turn is passed along to <code>sass</code>. Once <code>sass</code> is done doing its business, Hakyll then outputs the compiled data into <code>assets/main.css</code>.</p>
<p>It worked wonderfully, so I set about tackling more interesting problems with Hakyll. As work on the blog came to a close, I found myself wanting to tweak some designs within the theme. It felt as though it had accrued some cruft and I didn’t care for some of the previous aesthetic choices I had made.</p>
<p>While making alterations I discovered that <code>site watch</code> wasn’t observing the changes being made to the theme’s imported files. The previous solution works so long as you make no changes to any imported SCSS files and your directory structure looks a little something like what I had.</p>
<p>Hakyll was only being told to watch <code>novella.scss</code>, and not the files contained within the <code>novella</code> subdirectory. These conditions made it remarkably unpleasant to work with while frequently iterating and tweaking the design. The seemingly obvious solution would be to use a glob that permits recursion and matching of the inner style sheets.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">match <span class="st">&quot;scss/**.scss&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-2" title="2">  route <span class="fu">$</span> constRoute <span class="st">&quot;assets/main.css&quot;</span></a>
<a class="sourceLine" id="cb3-3" title="3">  compile compressScssCompiler</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">compressScssCompiler ::</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb3-6" title="6">compressScssCompiler <span class="fu">=</span> withItemBody <span class="fu">$</span> unixFilter <span class="st">&quot;sass&quot;</span> arguments</a>
<a class="sourceLine" id="cb3-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-8" title="8">    arguments <span class="fu">=</span> [ <span class="st">&quot;-s&quot;</span></a>
<a class="sourceLine" id="cb3-9" title="9">                , <span class="st">&quot;--scss&quot;</span></a>
<a class="sourceLine" id="cb3-10" title="10">                , <span class="st">&quot;--style&quot;</span>, <span class="st">&quot;compressed&quot;</span></a>
<a class="sourceLine" id="cb3-11" title="11">                ]</a></code></pre></div>
<p>This should work, only so long as there are no file dependencies. In the case of the Novella theme, there are many dependencies that are tied together by a single file.</p>
<p>After many failed attempts to skirt the issue, I discovered that Hakyll provides a marvellous solution to this very conundrum: <code>rulesExtraDependencies</code>. It ensures that any changes the compiler makes to files matching the specified dependencies are then processed with a follow-up build step. <code>makePatternDependency</code> is responsible for generating a <code>Dependency</code> structure from a given <code>Pattern</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">match <span class="st">&quot;scss/**.scss&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" title="2">  compile getResourceString</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4">scssDependency <span class="ot">&lt;-</span> makePatternDependency <span class="st">&quot;scss/**.scss&quot;</span></a>
<a class="sourceLine" id="cb4-5" title="5">rulesExtraDependencies [scssDependency] <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-6" title="6">  create [<span class="st">&quot;assets/main.css&quot;</span>] <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-7" title="7">    route idRoute</a>
<a class="sourceLine" id="cb4-8" title="8">    compile <span class="fu">$</span></a>
<a class="sourceLine" id="cb4-9" title="9">      loadBody <span class="st">&quot;scss/novella.scss&quot;</span></a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="fu">&gt;&gt;=</span> makeItem</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="fu">&gt;&gt;=</span> scssCompiler</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="ot">scssCompiler ::</span> <span class="dt">Item</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb4-14" title="14">scssCompiler <span class="fu">=</span> withItemBody <span class="fu">$</span> unixFilter <span class="st">&quot;sass&quot;</span> arguments</a>
<a class="sourceLine" id="cb4-15" title="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-16" title="16">    arguments <span class="fu">=</span> [ <span class="st">&quot;-s&quot;</span></a>
<a class="sourceLine" id="cb4-17" title="17">                , <span class="st">&quot;--scss&quot;</span></a>
<a class="sourceLine" id="cb4-18" title="18">                , <span class="st">&quot;--style&quot;</span>, <span class="st">&quot;compressed&quot;</span></a>
<a class="sourceLine" id="cb4-19" title="19">                , <span class="st">&quot;--load-path&quot;</span>, <span class="st">&quot;scss&quot;</span></a>
<a class="sourceLine" id="cb4-20" title="20">                ]</a></code></pre></div>
<p>Now the matcher contains the recursive glob, which is also reflected in the <code>makePatternDependency</code> call, and removes the route call. The compile step changes to retrieve the resource’s contents rather than sending it to <code>sass</code>. This change allows the <code>novella.scss</code> contents to be recalled in the dependency step while skipping over any <code>sass</code> compilations for the imported SCSS files. The dependency step, as just mentioned, recalls the contents of <code>novella.scss</code> and passes it along to <code>sass</code>. Hakyll then takes the output and writes it to <code>assets/main.css</code>.</p>
<p>Voilà! Hakyll will now update the CSS file whenever the any of the SCSS files are modified.</p>]]></summary>
</entry>
<entry>
    <title>Swift 4 Reusable Codable Structures</title>
    <link href="maroon.github.io/posts/2017/10/14/swift-reusable-codable-structures/" />
    <id>maroon.github.io/posts/2017/10/14/swift-reusable-codable-structures/</id>
    <published>2017-10-14T00:00:00Z</published>
    <updated>2017-10-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There is much pomp and circumstance over the new Swift <code>Codable</code> protocol. After indulging myself in the documentation and examples for a few hours, I couldn’t help but feel there was a glaring omission: reusable structures.</p>
<p>In several projects that I’ve worked on I have found a need for a common contract between responses. For instance, I may want to know if the request had a successful operation–– and if not, perhaps a message informing me what the server had to say about it. This essentially creates a wrapper around the otherwise simple payload structure. To make the example a bit more interesting I’ll convolute the common data with another wrapper around it. Thus, the payload will be contained within a result structure which is confined to a frivolous wrapper, like so:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="st">&quot;response&quot;</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="st">&quot;successful&quot;</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="st">&quot;message&quot;</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="st">&quot;payload&quot;</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">      <span class="st">&quot;first_name&quot;</span><span class="op">:</span> <span class="st">&quot;Ryan&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-7" title="7">      <span class="st">&quot;last_name&quot;</span><span class="op">:</span> <span class="st">&quot;Maroon&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-8" title="8">      <span class="st">&quot;hobby&quot;</span><span class="op">:</span> <span class="st">&quot;Programming&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="op">}</span></a></code></pre></div>
<p>Rather than constructing a very elaborate decoder path or rewriting the same boilerplate code for each structure, such behavior can be accommodated with the use of generics.</p>
<pre class="swift"><code>struct Response&lt;T: Codable&gt;: Codable {
  let result: Result&lt;T&gt;

  private enum CodingKeys: String, CodingKey {
    case result = &quot;response&quot;
  }
}

struct Result&lt;T: Codable&gt;: Codable {
  let successful: Bool
  let message: String?
  let payload: T
}</code></pre>
<p>Swift will now parse any payload data so long as it conforms to the <code>Codable</code> protocol. We’ll take a look at another example of this in a bit. First, let’s take a look at the response payload representing the person data set.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="st">&quot;first_name&quot;</span><span class="op">:</span> <span class="st">&quot;Ryan&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="st">&quot;last_name&quot;</span><span class="op">:</span> <span class="st">&quot;Maroon&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="st">&quot;hobby&quot;</span><span class="op">:</span> <span class="st">&quot;Programming&quot;</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>The structure for such a response would then be described as such:</p>
<pre class="swift"><code>struct Person: Codable {
  let firstName: String
  let lastName: String
  let hobby: String

  private enum CodingKeys: String, CodingKey {
    case firstName = &quot;first_name&quot;
    case lastName = &quot;last_name&quot;
    case hobby
  }
}</code></pre>
<p>Finally, the decoder would take the response data and the generic wrapper like this:</p>
<pre class="swift"><code>let decoder = JSONDecoder()
let payload = try! decoder.decode(Response&lt;Person.self&gt;, from: responseData)</code></pre>
<p>That’s it! Another example, as mentioned earlier, would be to utilize an array which also conforms to <code>Codable</code>. Assuming this is the payload from the server:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1">[</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="st">&quot;Haskell&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="st">&quot;Elixir&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="st">&quot;Elm&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-5" title="5">]</a></code></pre></div>
<p>The decoder call would then be expressed as:</p>
<pre class="swift"><code>let payload = try! decoder.decode(Response&lt;[String]&gt;.self, from: responseData)</code></pre>]]></summary>
</entry>
<entry>
    <title>Swift Package Manager and Generics</title>
    <link href="maroon.github.io/posts/2016/10/31/swift-package-manager-and-generics/" />
    <id>maroon.github.io/posts/2016/10/31/swift-package-manager-and-generics/</id>
    <published>2016-10-31T00:00:00Z</published>
    <updated>2016-10-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A while back I had completed updating an old flood fill algorithm when I realized it would be a great opportunity to play with the Swift Package Manager. I set off to break apart the monolithic project into several standalone pieces that I could reuse within other projects. In the end I created two modules: one for the flood fill algorithm and another for the stack that the algorithm depended upon. Afterwards I created an application to house the flood fill module and output the result to disk. Everything appeared to be going very well!</p>
<p>The layout for the project dependencies were remarkably linear: the <code>FloodFillApp</code> depended upon the <code>FloodFill</code> module which depended upon the <code>Stack</code> module. Originally, without the separate modules, my image was taking around 200 milliseconds to process in debug mode and 40 milliseconds in release mode. I realized there might be some slight performance degradation due to <code>-whole-module-optimization</code> not being able to optimize as efficiently across module boundaries, however I wasn’t quite prepared for a sudden jump to over <em>2 minutes</em> for my image! After double checking that I didn’t miss some obscure implementation detail, I decided to try release mode. Running <code>swift build -c release</code> brought me down <em>16 seconds</em>. Huzzah?</p>
<p>After a few days of pain and toil, I came across the core of my problem: generics. I had attempted to make my <code>Stack</code> module something that could be recycled into other projects, so generics were the obvious solution. Unfortunately, after all of the tests I performed, there was no solution that would enable better performance with the project and modules “as-is”. There are a couple of options to help with performance, but they each come with a steep cost.</p>
<ol type="1">
<li>Remove generics from the <code>Stack</code> module.</li>
<li>Move the <code>Stack</code> module inside the <code>FloodFill</code> module.</li>
<li>Use <code>@_specialize</code> on the generic class in the <code>Stack</code> module.</li>
</ol>
<p>Let’s take a look at each of those options.</p>
<p>Option 1’s cost is removing generics: your module won’t be as flexible or powerful as it could be using generics. This is impractical from a collection’s standpoint. Imagine if Swift had the same crippling limitation put on something as significant as its array class: we’d have an IntArray, DoubleArray, and so forth. It’d be rubbish to develop a collection module around a single type, each of which utilizing the exact same code with only the type changing.</p>
<p>That said, removing generics resolves the performance issues significantly. Running this in release mode with separate modules yields a 50 millisecond execution time.</p>
<p>Option 2’s cost is the equivalent of removing Swift Package Manager entirely and sticking everything back into the monolithic project. This, unfortunately, seems to be the best option. Without the ability to optimize for generics across module boundaries, we are right back to putting the project file in the workspace and manually linking the frameworks up from there.</p>
<p>Option 3’s cost is specializing a generic with a <em>single known</em> concrete attribute. Of the three options I’ve found, I don’t consider this a viable solution in any sense. Let me first give you an idea of what this decorator does: from the <a href="https://github.com/apple/swift/blob/master/docs/Generics.rst#specialization">Swift ‘Generics.rst’ document</a>:</p>
<blockquote>
<p><span class="citation" data-cites="_specialize">@_specialize</span> currently acts as a hint to the optimizer, which generates type checks and code to dispatch to the specialized routine without affecting the signature of the generic function. The intention is to support efforts at evaluating the performance of specialized code. The performance impact is not guaranteed and is likely to change with the optimizer. This attribute should only be used in conjunction with rigorous performance analysis. Eventually, a similar attribute could be defined in the language, allowing it to be exposed as part of a function’s API. That would allow direct dispatch to specialized code without type checks, even across modules.</p>
</blockquote>
<p>The document also gives this code use example:</p>
<pre class="swift"><code>struct S&lt;T&gt; {
  var x: T
  @_specialize(Int, Float)
  mutating func exchangeSecond&lt;U&gt;(_ u: U, _ t: T) -&gt; (U, T) {
    x = t
    return (u, x)
  }
}

// Substitutes: &lt;T, U&gt; with &lt;Int, Float&gt; producing:
// S&lt;Int&gt;::exchangeSecond&lt;Float&gt;(u: Float, t: Int) -&gt; (Float, Int)</code></pre>
<p>What I have found is that, yes, this does alleviate the problem that I’ve described in this post, however, <em>only the module dependency can call this</em>. This effectively means that only one type, the specialized type, will be performant–– everything else will suffer. If the <code>Stack</code> module were to use this decorator on the <code>push</code> and <code>pop</code> methods for the <code>Int</code> type, any other type, such as <code>Double</code>, would have the <em>same</em> terrible performance degradation that I’ve described.</p>
<p>That said, the performance of using <code>@_specialize</code> garnered a 90 millisecond execution time. That’s over double the integrated, non-generic version of this project. When I originally separated everything into separate modules, this is roughly the level of performance that I had anticipated it being. For myself, it would be considered an acceptable performance penalty in order to maintain separate module boundaries and to isolate the scope of each project.</p>]]></summary>
</entry>

</feed>
